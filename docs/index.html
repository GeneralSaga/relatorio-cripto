<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatório Dinâmico de Criptoativos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0d1a2f; color: #e2e8f0; }
        .text-blue-500 { color: #5B84B1; }
        .bg-blue-900 { background-color: #1c3358; }
        .chart-container { position: relative; width: 100%; max-width: 400px; margin-left: auto; margin-right: auto; height: 200px; max-height: 220px; }
        .info-badge { padding: 4px 12px; border-radius: 9999px; font-weight: 700; font-size: 1rem; }
        .info-green { background-color: rgba(124, 252, 0, 0.2); color: #7CFC00; }
        .info-yellow { background-color: rgba(255, 215, 0, 0.2); color: #FFD700; }
        .info-red { background-color: rgba(255, 69, 0, 0.2); color: #FF4500; }
        .extra-badge { background-color: rgba(255, 255, 255, 0.1); color: #e2e8f0; padding: 4px 12px; border-radius: 9999px; font-weight: 700; font-size: 1rem; }
        .text-gradient { background: linear-gradient(90deg, #6a85b9, #adc6e0); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.1); border-left-color: #ffffff; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .tooltip-container { position: relative; display: inline-block; cursor: pointer; }
        .tooltip-text { visibility: hidden; background-color: #1a2a47; color: #fff; text-align: center; border-radius: 6px; padding: 5px 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -75px; opacity: 0; transition: opacity 0.3s; width: 150px; font-size: 0.8rem; }
        .tooltip-text::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #1a2a47 transparent transparent transparent; }
        .tooltip-container:hover .tooltip-text { visibility: visible; opacity: 1; }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto px-4 py-12 md:px-8">
        <header class="text-center mb-16">
            <h1 class="text-4xl md:text-6xl font-extrabold text-white">Relatório de Criptoativos</h1>
            <p class="mt-4 max-w-3xl mx-auto text-lg text-slate-400">Clique no botão para buscar e categorizar os dados de criptoativos em tempo real.</p>
        </header>

        <main>
            <section id="data-input" class="mb-16">
                <div class="bg-blue-900 rounded-2xl p-6 shadow-2xl border border-blue-800 max-w-4xl mx-auto">
                    <h2 class="text-2xl font-bold text-gradient text-center mb-4">Atualizar Dados</h2>
                    <div class="flex flex-col md:flex-row justify-center items-center gap-4 mt-4">
                        <button id="api-coingecko-button" class="bg-blue-500 text-white font-bold py-2 px-6 rounded-full shadow-lg hover:bg-blue-600 transition-colors flex items-center justify-center gap-2">
                            <span id="button-text-coingecko">Atualizar (CoinGecko)</span>
                            <div id="loading-spinner-coingecko" class="spinner hidden"></div>
                        </button>
                        <button id="api-coinmarketcap-button" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-full shadow-lg hover:bg-purple-700 transition-colors flex items-center justify-center gap-2">
                            <span id="button-text-coinmarketcap">Atualizar (CoinMarketCap)</span>
                            <div id="loading-spinner-coinmarketcap" class="spinner hidden"></div>
                        </button>
                    </div>
                    <div id="status-message" class="text-center mt-4 text-sm text-red-400"></div>
                </div>
            </section>

            <section id="most-potential" class="mb-20">
                <h2 class="text-3xl md:text-4xl font-bold mb-8 text-center text-gradient">Ativos em Destaque Hoje</h2>
                <div id="potential-list" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-8"></div>
            </section>
            
            <section id="recently-launched" class="mb-20">
                <h2 class="text-3xl md:text-4xl font-bold mb-8 text-center text-gradient">Recém-Lançadas em Destaque</h2>
                <div id="new-list" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-8"></div>
            </section>
            
            <section id="cryptos" class="mb-20">
                <h2 class="text-3xl md:text-4xl font-bold mb-8 text-center text-gradient">Criptomoedas Fundamentais</h2>
                <div id="crypto-list" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-8"></div>
            </section>

            <section id="tokens" class="mb-20">
                <h2 class="text-3xl md:text-4xl font-bold mb-8 text-center text-gradient">Tokens de Utilidade & DeFi</h2>
                <div id="token-list" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-8"></div>
            </section>

            <section id="memecoins" class="mb-16">
                <h2 class="text-3xl md:text-4xl font-bold mb-8 text-center text-gradient">Memecoins Especulativas</h2>
                <div id="memecoin-list" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-8"></div>
            </section>
        </main>
        <footer class="text-center border-t border-slate-700 pt-8 mt-12">
            <p class="text-slate-500 text-sm"><strong>Aviso Legal:</strong> Este relatório é gerado para fins educacionais e não constitui aconselhamento financeiro. A pontuação de potencial é baseada em um modelo algorítmico e não garante lucros.</p>
        </footer>
    </div>

    <script>
        let charts = {};

        const formatNumber = (num) => {
            if (num === null || num === undefined) return 'N/A';
            if (num >= 1e12) return `$${(num / 1e12).toFixed(2)}T`;
            if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
            if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
            if (num > 0 && num < 0.01) return `$${num.toPrecision(2)}`;
            return `$${num.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        };

        const calculatePotentialScore = (asset) => {
            if (!asset || asset.marketCap === 0) return 0;
            let score = 0;
            const priceChange = asset.price_change_percentage_24h;
            const volToMcRatio = asset.volume / asset.marketCap;

            if (priceChange > 15) score += 3;
            else if (priceChange > 5) score += 2;
            else if (priceChange > 0) score += 1;

            if (volToMcRatio > 0.5) score += 3;
            else if (volToMcRatio > 0.2) score += 2;
            else if (volToMcRatio > 0.1) score += 1;

            if (asset.marketCap < 100e6) score += 2;
            else if (asset.marketCap < 1e9) score += 1;

            return score;
        };
        
        const getScoreLabel = (score) => {
            if (score >= 7) return { label: 'Potencial Altíssimo', class: 'info-green' };
            if (score >= 5) return { label: 'Potencial Alto', class: 'info-green' };
            if (score >= 3) return { label: 'Potencial Moderado', class: 'info-yellow' };
            return { label: 'Potencial Baixo', class: 'info-red' };
        };

        const calculateDaysSinceListing = (genesisDate) => {
            if (!genesisDate) return 'N/A';
            const today = new Date();
            const listingDate = new Date(genesisDate);
            const diffTime = Math.abs(today - listingDate);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        };

        const createAssetCard = (asset) => {
            const score = calculatePotentialScore(asset);
            const { label: scoreLabel, class: scoreClass } = getScoreLabel(score);
            const priceChange24h = asset.price_change_percentage_24h;
            const priceChangeText = priceChange24h?.toFixed(2) + '%' || 'N/A';
            const priceChangeColor = priceChange24h >= 0 ? 'text-green-400' : 'text-red-400';
            const daysOnMarket = calculateDaysSinceListing(asset.genesis_date);
            const category = asset.categories?.[0] || "Sem Categoria";

            const valuationContent = asset.marketCap > 0 ? `<div class="chart-container"><canvas id="valuation-${asset.id}"></canvas></div>` : `<div class="h-[200px] flex items-center justify-center text-center text-sm text-slate-500">Dados indisponíveis.</div>`;
            const supplyContent = asset.circulatingSupply > 0 ? `<div class="chart-container"><canvas id="supply-${asset.id}"></canvas></div>` : `<div class="h-[200px] flex items-center justify-center text-center text-sm text-slate-500">Dados indisponíveis.</div>`;
            
            return `
                <div class="bg-blue-900 rounded-2xl p-6 shadow-2xl border border-blue-800">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                        <h3 class="text-2xl font-bold text-white">${asset.name}</h3>
                        <div class="flex items-center gap-2 mt-2 sm:mt-0">
                            <div class="${scoreClass} info-badge">${scoreLabel}</div>
                            <div class="extra-badge ${priceChangeColor}">${priceChangeText}</div>
                        </div>
                    </div>
                    <div class="flex justify-center w-full mb-4">
                        <span class="bg-slate-700 text-slate-300 rounded-full px-4 py-1 text-sm font-medium">${category}</span>
                    </div>
                    <div class="grid grid-cols-3 gap-4 text-center mb-6">
                        <div><p class="text-sm text-blue-500">Preço</p><p class="text-xl font-semibold text-white">${formatNumber(asset.price)}</p></div>
                        <div class="tooltip-container"><p class="text-sm text-blue-500">Market Cap</p><p class="text-xl font-semibold text-white">${formatNumber(asset.marketCap)}</p><span class="tooltip-text">Valor total das moedas em circulação.</span></div>
                        <div><p class="text-sm text-blue-500">Dias no Mercado</p><p class="text-xl font-semibold text-white">${daysOnMarket}</p></div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="tooltip-container"><h4 class="font-semibold text-center mb-2 text-slate-300">Valuation</h4>${valuationContent}<span class="tooltip-text">Market Cap vs Valor Totalmente Diluído.</span></div>
                        <div class="tooltip-container"><h4 class="font-semibold text-center mb-2 text-slate-300">Oferta</h4>${supplyContent}<span class="tooltip-text">Moedas em circulação vs Oferta Total.</span></div>
                    </div>
                    <div class="mt-6 text-center"><a href="details.html?id=${asset.id}" class="bg-slate-700 text-slate-200 hover:bg-slate-600 font-bold py-2 px-6 rounded-full inline-block transition-colors">Ver Detalhes</a></div>
                </div>`;
        };

        const renderCharts = (asset) => {
            if (charts[`valuation-${asset.id}`]) charts[`valuation-${asset.id}`].destroy();
            if (charts[`supply-${asset.id}`]) charts[`supply-${asset.id}`].destroy();

            if (asset.marketCap > 0) {
                const valuationCtx = document.getElementById(`valuation-${asset.id}`)?.getContext('2d');
                if (valuationCtx) charts[`valuation-${asset.id}`] = new Chart(valuationCtx, { type: 'bar', data: { labels: ['Market Cap', 'Valor Diluído'], datasets: [{ data: [asset.marketCap, asset.fdv || asset.marketCap], backgroundColor: ['#6a85b9', '#adc6e0'] }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { display: false }, x: { ticks: { color: '#94a3b8' } } } } });
            }

            if (asset.circulatingSupply > 0) {
                const supplyCtx = document.getElementById(`supply-${asset.id}`)?.getContext('2d');
                if (supplyCtx) {
                    const total = asset.maxSupply || asset.totalSupply;
                    const nonCirculating = total > asset.circulatingSupply ? total - asset.circulatingSupply : 0;
                    charts[`supply-${asset.id}`] = new Chart(supplyCtx, { type: 'doughnut', data: { labels: ['Em Circulação', 'Não Circulante'], datasets: [{ data: [asset.circulatingSupply, nonCirculating], backgroundColor: ['#5B84B1', '#2f4c7d'], borderColor: '#0d1a2f' }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '70%', plugins: { legend: { display: true, position: 'bottom', labels: { color: '#94a3b8' } } } } });
                }
            }
        };
        
        const renderSection = (sectionId, data) => {
            const container = document.getElementById(sectionId);
            if (!container) return;
            container.innerHTML = data.length === 0 ? `<p class="text-center text-slate-500 col-span-full">Nenhum ativo encontrado.</p>` : data.map(createAssetCard).join('');
            setTimeout(() => data.forEach(renderCharts), 0);
        };

        const setLoadingState = (buttonId, textId, spinnerId, isLoading) => {
            document.getElementById(buttonId).disabled = isLoading;
            document.getElementById(textId).textContent = isLoading ? 'Buscando...' : document.getElementById(textId).dataset.originalText;
            document.getElementById(spinnerId).classList.toggle('hidden', !isLoading);
        };
        
        // Função utilitária para criar um atraso
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const fetchDataFromCoinGecko = async () => {
            setLoadingState('api-coingecko-button', 'button-text-coingecko', 'loading-spinner-coingecko', true);
            const status = document.getElementById('status-message');
            status.textContent = 'Buscando dados da CoinGecko...';
            status.style.color = '#FFD700';
            
            const apiKey = 'CG-yd15f3vAJQP8GNw94nKVQjW2';
            const vsCurrency = 'usd';

            try {
                // ETAPA 1: Chamadas iniciais paralelas (3 requisições)
                const [marketsResponse, memecoinsResponse, newCoinsResponse] = await Promise.all([
                    fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=${vsCurrency}&order=market_cap_desc&per_page=250&page=1&x_cg_demo_api_key=${apiKey}`),
                    fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=${vsCurrency}&category=meme-token&order=market_cap_desc&per_page=50&page=1&x_cg_demo_api_key=${apiKey}`),
                    fetch(`https://api.coingecko.com/api/v3/coins/new?x_cg_demo_api_key=${apiKey}`)
                ]);

                if (!marketsResponse.ok || !memecoinsResponse.ok || !newCoinsResponse.ok) {
                    throw new Error(`Erro na busca primária de dados (CoinGecko).`);
                }

                let allMarketData = await marketsResponse.json();
                let memecoinData = await memecoinsResponse.json();
                let newCoinsDataRaw = await newCoinsResponse.json();
                
                // ETAPA 2: Busca por detalhes de moedas recém-lançadas, se existirem (1 requisição)
                const newCoinIds = newCoinsDataRaw.slice(0, 50).map(c => c.id).join(',');
                let newCoinsMarketData = [];
                if (newCoinIds) {
                    const newCoinsMarketResponse = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=${vsCurrency}&ids=${newCoinIds}&x_cg_demo_api_key=${apiKey}`);
                    if (newCoinsMarketResponse.ok) newCoinsMarketData = await newCoinsMarketResponse.json();
                }

                // ETAPA 3: Juntar todos os IDs únicos para buscar detalhes (requisições sequenciais)
                const allIds = [...new Set([
                    ...allMarketData.map(c => c.id),
                    ...memecoinData.map(c => c.id),
                    ...newCoinsMarketData.map(c => c.id)
                ])].slice(0, 20); // Limita o número de moedas para respeitar o limite de 30 chamadas
                
                status.textContent = 'Processando dados... Isso pode levar um minuto.';
                
                const detailsMap = {};
                for (const id of allIds) {
                    try {
                        const res = await fetch(`https://api.coingecko.com/api/v3/coins/${id}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false&x_cg_demo_api_key=${apiKey}`);
                        if (res.ok) {
                            const coin = await res.json();
                            detailsMap[id] = { genesis_date: coin.genesis_date, categories: coin.categories?.filter(c => c) };
                        }
                    } catch (e) {
                        console.error(`Falha ao buscar detalhes para o ID ${id}:`, e);
                    }
                    await delay(2500); // Adiciona um atraso de 2.5 segundos
                }
                
                // ETAPA 4: Mapear, enriquecer e classificar os dados
                const mapAndEnrich = (coin) => ({
                    id: coin.id, symbol: coin.symbol, name: coin.name, price: coin.current_price, marketCap: coin.market_cap,
                    fdv: coin.fully_diluted_valuation, volume: coin.total_volume, circulatingSupply: coin.circulating_supply,
                    maxSupply: coin.max_supply, totalSupply: coin.total_supply, price_change_percentage_24h: coin.price_change_percentage_24h,
                    genesis_date: detailsMap[coin.id]?.genesis_date, categories: detailsMap[coin.id]?.categories || ['Geral'],
                });
                
                const sortLogic = (a, b) => calculatePotentialScore(b) - calculatePotentialScore(a);

                const allMappedData = allMarketData.map(mapAndEnrich);
                
                const mostPotential = [...allMappedData].sort(sortLogic).slice(0, 10);
                const fundamentalCryptos = allMappedData.filter(c => c.marketCap > 1e9).sort(sortLogic).slice(0, 10);
                const utilityTokens = allMappedData.filter(c => c.marketCap > 1e6 && c.marketCap < 1e9).sort(sortLogic).slice(0, 10);
                const recentlyLaunched = newCoinsMarketData.map(mapAndEnrich).sort(sortLogic).slice(0, 10);
                const memecoins = memecoinData.map(mapAndEnrich).sort(sortLogic).slice(0, 10);
                
                renderSection('potential-list', mostPotential);
                renderSection('crypto-list', fundamentalCryptos);
                renderSection('token-list', utilityTokens);
                renderSection('new-list', recentlyLaunched);
                renderSection('memecoin-list', memecoins);

                status.textContent = 'Relatório atualizado com sucesso (CoinGecko)!';
                status.style.color = '#7CFC00';
            } catch (e) {
                status.textContent = `Erro (CoinGecko): ${e.message}. Tente novamente.`;
                status.style.color = '#FF4500';
            } finally {
                setLoadingState('api-coingecko-button', 'button-text-coingecko', 'loading-spinner-coingecko', false);
            }
        };

        const fetchDataFromCoinMarketCap = async () => {
            setLoadingState('api-coinmarketcap-button', 'button-text-coinmarketcap', 'loading-spinner-coinmarketcap', true);
            const status = document.getElementById('status-message');
            status.textContent = 'Buscando dados da CoinMarketCap...';
            status.style.color = '#FFD700';

            const apiKey = '65a1fea9-f3b5-459e-aee4-942bdaaed6c5'; // CHAVE INVÁLIDA
            const vsCurrency = 'USD'; // A CoinMarketCap usa letras maiúsculas para moedas

            try {
                const response = await fetch(`https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?start=1&limit=250&convert=${vsCurrency}`, {
                    headers: { 'X-CMC_PRO_API_KEY': apiKey }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.status.error_message || 'Erro na busca de dados (CoinMarketCap).');
                }

                const data = await response.json();
                const allMarketData = data.data;

                const mapAndEnrichCMC = (coin) => {
                    const quote = coin.quote[vsCurrency];
                    return {
                        id: coin.id,
                        symbol: coin.symbol,
                        name: coin.name,
                        price: quote.price,
                        marketCap: quote.market_cap,
                        fdv: quote.fully_diluted_market_cap,
                        volume: quote.volume_24h,
                        circulatingSupply: coin.circulating_supply,
                        maxSupply: coin.max_supply,
                        totalSupply: coin.total_supply,
                        price_change_percentage_24h: quote.percent_change_24h,
                        genesis_date: null, // CMC não fornece isso no endpoint 'listings'
                        categories: ['Geral']
                    };
                };

                const sortLogic = (a, b) => calculatePotentialScore(b) - calculatePotentialScore(a);

                const allMappedData = allMarketData.map(mapAndEnrichCMC);
                
                const mostPotential = [...allMappedData].sort(sortLogic).slice(0, 10);
                const fundamentalCryptos = allMappedData.filter(c => c.marketCap > 1e9).sort(sortLogic).slice(0, 10);
                const utilityTokens = allMappedData.filter(c => c.marketCap > 1e6 && c.marketCap < 1e9).sort(sortLogic).slice(0, 10);
                
                // As categorias 'recém-lançadas' e 'memecoins' precisam de endpoints diferentes na CMC, então as seções serão deixadas vazias por simplicidade.
                renderSection('potential-list', mostPotential);
                renderSection('crypto-list', fundamentalCryptos);
                renderSection('token-list', utilityTokens);
                renderSection('new-list', []);
                renderSection('memecoin-list', []);

                status.textContent = 'Relatório atualizado com sucesso (CoinMarketCap)!';
                status.style.color = '#7CFC00';
            } catch (e) {
                status.textContent = `Erro (CoinMarketCap): ${e.message}. Verifique sua chave de API.`;
